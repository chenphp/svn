\documentclass[nofonts, oneside]{ctexbook}

\usepackage{xeCJK}
\usepackage{hyperref}
\usepackage{makeidx}
\usepackage{listings}

\newcommand\shellcmd[1]{\texttt{#1}}
\newcommand\svn{\texttt{svn}}
\newcommand\svnci{\texttt{commit}}

\lstnewenvironment{svnshell}
  {
    \lstset{basicstyle = \ttfamily,
        tabsize = 4,
        xleftmargin = 2em,
        frame = single,
        escapechar = &,
    }
  }
  {}
\lstnewenvironment{ccode}
  {
    \lstset{basicstyle = \ttfamily,
        tabsize = 4,
        xleftmargin = 2em,
        frame = single,
    }
  }
  {}

\makeindex
\setCJKmainfont{AR PL UMing CN}
\setCJKsansfont{AR PL UMing CN}
\setCJKmonofont[Scale=0.9]{AR PL UMing CN}
\setmainfont{FreeSerif}
\setsansfont{FreeSans}
% "Mapping={}" make quote symbol straight
\setmonofont[Mapping={}]{FreeMono}

\title{SVN 教程}
\author{\url{www.tutorialspoint.com/svn/index.htm} \and
	\url{https://github.com/wuzhouhui/svn}}

\begin{document}

\maketitle

\chapter{基本概念}
\label{chap:basic_concepts}

\section{什么是版本控制系统}
\label{sec:what_is_version_control_system}

版本控制系统 (Version Control System\index{Version Control System (版本控制
系统)}, 简称 VCS) 是一种软件, 它可以帮助软件开发人员协同工作, 以及管理产品的
完整历史.

版本控制系统的目标包括:
\begin{itemize}
  \item 支持多人同时操作.
  \item 不覆盖其他人作出的修改.
  \item 维护每一个版本的历史.
\end{itemize}

VCS 可以分成两大类别:
\begin{itemize}
  \item 集中式的版本控制系统 (Centralized Version Control System\index{
   Centralized Control System (集中式的版本控制系统)}, 简称 CVCS);
  \item 分布式的版本控制系统 (Distributed Version Control System\index{
   Distributed Version Control System (分布式的版本控制系统)}, 简称 DVCS).
\end{itemize}

本教程只讨论 CVCS, 特别是 Subversion\index{Subversion}, 它使用中央服务器来存
储所有的文件, 并支持团队协作.

\section{版本控制术语}
\label{sec:version_control_terminologies}

首先先来介绍本教程将会用到的几个术语.

\begin{itemize}
  \item 仓库 (Repository\index{repository (仓库)}): 仓库是所有版本控制系统的
      核心, 它是开发人员存放所有资料的中心目录. 除了文件, 仓库还会存放历史.
      仓库支持网络访问, 相当于一个服务器, 而版本控制工具则是客户端. 客户端可
      以连接仓库, 然后就可以向仓库提交修改, 或检索修改历史. 通过提交, 其他客
      户端就可以看到某个客户端作出的修改; 通过检查修改历史, 客户端就可以把其
      他人的修改作为工作副本.

  \item 主干 (Trunk\index{trunk (主干)}): 主干是一个目录, 它是所有主要开发发
      生的地方, 通常会被开发人员检出, 以便进行项目开发.

  \item 标签 (Tags\index{tags (标签)}): 标签是用于存放项目的命名快照的目录. 通
      过标签, 开发人员可以给仓库的某个特定版本取一个描述性的, 易于记忆的名字.

      比如, \texttt{LAST\_STABLE\_CODE\_BEFORE\_EMAIL\_SUPPORT} 就比
      \texttt{Repository UUID: 7ceef8cb-3799-40dd-a067-c216ec2e5247} 和
      \texttt{Revision: 13} 容易记忆.

  \item 分支 (Branches\index{branch (分支)}): 分支用来创建一条新的开发线. 如
      果开发人员想要把开发过程分裂成两个方向, 就会用到该功能. 例如, 开发人员
      在发布了 5.0 版本后, 可能会创建一条新的分支, 专门用于开发 6.0 版本,
      这样的话, 6.0 的开发就不会与 5.0 的问题修复相互混淆.

  \item 工作副本 (Working copy\index{working copy (工作副本)}): 工作副本是仓库
      的一个快照. 仓库被团队内的所有人共享, 但人们不能直接修改仓库, 解决办法是
      每个开发人员都从仓库中检出一份工作副本, 这个工作副本就是他的私有工作区,
      开发人员在工作副本中所做的工作并不会影响到团队中的其他人.

  \item 提交修改 (Commit changes\index{commit changes (提交修改)}): 把私有工作
      区的修改存放到中央服务器的过程称为提交. 提交后, 团队中的其他人就可以看到
      别人作出的修改, 通过检索修改, 开发人员可以把修改更新到他们的工作副本中.
      提交是一个原子操作, 要么全部的修改提交成功, 要么全部失败, 不可能出现只
      提交一半的情况.
\end{itemize}

\chapter{环境设置}
\label{chap:environment_setup}

\section{安装 SVN}
\label{sec:svn_installation}

Subversion\index{Subversion} 是一款流行的版本控制工具, 它是开源软件, 可以在
因特网上免费获取. 大部分 GNU/Linux 发行版都默认安装了 Subversion, 可以用下面
的命令检查:
\begin{svnshell}
[jerry@CentOS ~]$ svn --version&\index{\texttt{svn}!\texttt{--version}}&
\end{svnshell}
如果系统中已经安装了 Subversion 客户端, 命令就会输出 Subversion 的版本号, 否则
的话, 就会输出一条错误信息:
\begin{svnshell}
[jerry@CentOS ~]$ svn --version&\index{\texttt{svn}!\texttt{--version}}&
-bash: svn: command not found
\end{svnshell}

如果你用的是基于 RPM 的 GNU/Linux 发行版, 可以用命令
\shellcmd{yum}\index{\texttt{yum}}
来安装
Subversion, 安装完成后, 再执行 \shellcmd{svn --version} 检查是否安装成功:
\begin{svnshell}
[jerry@CentOS ~]$ su -
Password:
[jerry@CentOS ~]# yum install subversion&\index{\texttt{yum}!\texttt{install}}&

[jerry@CentOS ~]$ svn --version&\index{\texttt{svn}!\texttt{--version}}&
svn, version 1.6.11 (r934486)
compiled Jun 23 2012, 00:44:03
\end{svnshell}

如果是 Debian 系列的 GNU/Linux 发行版, 就用命令
\shellcmd{apt}\index{\texttt{apt}} 安装:
\begin{svnshell}
    [jerry@Ubuntu]$ sudo apt-get update&\index{\texttt{apt}!\texttt{update}}&
[sudo] password for jerry:

[jerry@Ubuntu]$ sudo apt-get install subversion&\index{\texttt{apt}!\texttt{install}}&

[jerry@Ubuntu]$ svn --version&\index{\texttt{svn}!\texttt{--version}}&
svn, version 1.7.5 (r1336830)
compiled Jun 21 2013, 22:11:49
\end{svnshell}

\section{Apache 设置}
\label{sec:apache_setup}

上面我们已经介绍了如何在 GNU/Linux 中安装 Subversion 客户端, 现在介绍如何创建
一个新的仓库, 并设置访问权限.

在服务器端, 我们需要安装 Apache \shellcmd{httpd}\index{\texttt{httpd}} 模块和
\shellcmd{svnadmin}\index{\texttt{svnadmin}} 工具:
\begin{svnshell}
[jerry@CentOS ~]$ su -
Password:
[root@CentOS ~]# yum install&\index{\texttt{yum}!\texttt{install}}& mod_dav_svn subversion
\end{svnshell}
安装了软件包 \texttt{mod\_dav\_svn}\index{\texttt{mod\_dav\_svn}} 之后, 用户就
可以用 HTTP 来访问仓库, 软件包
\texttt{subversion} 包含了
\shellcmd{svnadmin}\index{\texttt{svnadmin}} 工具.

\texttt{/etc/httpd/conf.d/subversion.conf}\index{\texttt{subversion.conf}} 是 Subversion
的配置文件, 该文件的典型内容如下:
\begin{svnshell}
LoadModule dav_svn_module   modules/mod_dav_svn.so
LoadModule authz_svn_module modules/mod_authz_svn.so

<Location /svn>
    DAV svn
    SVNParentPath /var/www/svn
    AuthType Basic
    AuthName "Authorization Realm"
    AuthUserFile /etc/svn-users
    Require valid-user
</Location>
\end{svnshell}

现在我们开始创建 Subversion 用户, 并赋予他们访问仓库的权限. 命令
\shellcmd{htpasswd}\index{\texttt{htpasswd}} 用于创建和更新纯文本文件,
这些文件中存放
着用户名和密码. 如果指定了选项 \shellcmd{-c}, 则命令会创建一个密码文件, 如果
密码文件已经存在, 就会被覆盖, 因此选项 \shellcmd{-c} 只在第一次时用到. 选项
\shellcmd{-m} 开启密码的 MD5 加密.

假设现在我们要创建用户 \texttt{tom}:
\begin{svnshell}
[root@CentOS ~]# htpasswd&\index{\shellcmd{htpasswd}}& -cm /etc/svn-users tom
New password:
Re-type new password:
Adding password for user tom
\end{svnshell}

再创建一个用户 \texttt{jerry}:
\begin{svnshell}
[root@CentOS ~]# htpasswd&\index{\shellcmd{htpasswd}}& -cm /etc/svn-users jerry
New password:
Re-type new password:
Adding password for user jerry
\end{svnshell}

创建 Subversion 父目录, 用于存放所有的工作  (见
\texttt{/etc/httpd/conf.d/subversion.conf}\index{\texttt{subversion.conf}}):
\begin{svnshell}
[root@CentOS ~]# mkdir&\index{\shellcmd{mkdir}}& -p /var/www/svn
\end{svnshell}

\section{设置仓库}
\label{sec:repository_setup}
现在让我们来创建一个名为 \texttt{project\_repo} 的项目仓库. 命令
\shellcmd{svnadmin}\index{\texttt{svnadmin}} 在创建一个新的仓库时, 会在其中
创建几个目录, 用于存放元数据:
\begin{svnshell}
[root@CentOS svn]# pwd&\index{\texttt{pwd}}&
/var/www/svn
[root@CentOS svn]# svnadmin&\index{\texttt{svnadmin}}& create&\index{\texttt{svnadmin}!\texttt{create}}& project_repo
[root@CentOS svn]# ls&\index{\texttt{ls}}& -l project_repo
total 24
drwxr-xr-x. 2 root root 4096 Aug  4 22:30 conf
drwxr-xr-x. 6 root root 4096 Aug  4 22:30 db
-r--r--r--. 1 root root    2 Aug  4 22:30 format
drwxr-xr-x. 2 root root 4096 Aug  4 22:30 hooks
drwxr-xr-x. 2 root root 4096 Aug  4 22:30 locks
-rw-r--r--. 1 root root  229 Aug  4 22:30 README.txt
\end{svnshell}
然后, 我们要修改仓库目录的用户与用户组:
\begin{svnshell}
[root@CentOS svn]# chown&\index{\texttt{chown}}& -R apache.apache project_repo/
\end{svnshell}
查看 SELinux\index{SELinux} 是否开启:
\begin{svnshell}
[root@CentOS svn]# sestatus&\index{SELinux!\texttt{sestatus}}&
SELinux status:             enabled
SELinuxfs mount:            /selinux
Current mode:               enforcing
Mode from config file:      enforcing
Policy version:             24
Policy from config file:    targeted
\end{svnshell}
在笔者的环境中, SELinux 默认是开启的, 因此我们还需要修改 SELinux 的安全上下文:
\begin{svnshell}
[root@CentOS svn]# chcon&\index{SELinux!\texttt{chcon}}& -R -t httpd_sys_content_t \
> /var/www/svn/project_repo/
\end{svnshell}
为了能让开发人员通过 HTTP 进行提交, 执行:
\begin{svnshell}
[root@CentOS svn]# chcon&\index{SELinux!\texttt{chcon}}& -R -t httpd_sys_rw_content_t \
> /var/www/svn/project_repo/
\end{svnshell}
和 Apache 相关的配置到这里为止就全部结束了, 现在我们需要重启一下 Apache 服务:
\begin{svnshell}
[root@CentOS svn]# service httpd restart
Stopping httpd                          [FAILED]
Starting httpd: httpd: apr_sockaddr_info_get() failed for CentOS
httpd: Could not reliably determine the server's fully qualified domain
name, using 127.0.0.1 for ServerName
                                        [  OK  ]
[root@CentOS svn]# service httpd status
httpd (pid 1372) is running...
\end{svnshell}

接下来, 我们需要对仓库进行配置. 为了实现只有授权的用户才能访问仓库, 并且使用
默认的授权文件, 就把下面几行添加到
\texttt{project\_repo/conf/svnserve.conf}\index{\texttt{svnserve.conf}}
文件中.
\begin{svnshell}
anon-access = none
authz-db = authz
\end{svnshell}

传统上, 每一个仓库下面都有 \texttt{trunk}, \texttt{tags} 和 \texttt{branches}
这三个目录.

目录 \texttt{trunk}\index{\texttt{trunk}} 是主要开发发生的地方, 通常会被开发
人员检出, 以便进行项目开发.

目录 \texttt{tags}\index{\texttt{tags}} 用于存放项目的命名快照. 当需要发布
一个产品版本时, 团队就会给代码打一个标签, 然后存放到这个目录中并发布.

目录 \texttt{branches}\index{\texttt{branches}} 用于存放不同的开发线.

现在, 我们就要在仓库中创建 \texttt{trunk}, \texttt{tags}, 和 \texttt{branches}
这三个目录:
\begin{svnshell}
[root@CentOS svn]# mkdir&\index{\texttt{mkdir}}& /tmp/svn-template
[root@CentOS svn]# mkdir /tmp/svn-template/trunk
[root@CentOS svn]# mkdir /tmp/svn-template/branches
[root@CentOS svn]# mkdir /tmp/svn-template/tags
[root@CentOS svn]# svn import&\index{\texttt{svn}!\texttt{import}}& -m 'Create trunk, branches, tags directory structure' /tmp/svn-template/
Adding              /tmp/svn-template/trunk
Adding              /tmp/svn-template/branches
Adding              /tmp/svn-template/tags
Committed revision 1.
[root@CentOS svn]#
\end{svnshell}

到这里为止, 我们已经成功创建了一个仓库, 该仓库允许 \texttt{tom} 和
\texttt{jerry} 访问, 从现在开始, 他们两个就可以对仓库进行操作了.

\chapter{生命周期}
\label{chap:life_cycle}

本章讨论版本控制系统的生命周期, 再下一章介绍每一种操作对应的 Subversion 命令.

\section{创建仓库}
\label{sec:create_repository}

仓库是开发人员存放所有资料的目录. 除了文件, 仓库还会记录下各个文件的修改历史.
操作 create 用于创建一个新的仓库, 在大多数情况下, 这种操作只会做一次. 当开发
人员创建一个新的仓库时, VCS 会要求你输入一些信息, 比如仓库的创建位置, 仓库的
名字等.

\section{检出}
\label{sec:checkout}

操作 checkout 用来从仓库中创建一个工作副本到本地. 工作副本是开发人员私有的工
作空间, 他们在工作副本中作出修改, 然后再提交到仓库上.

\section{更新}
\label{sec:update}

顾名思义, 操作 update 用来更新工作副本, 它把本地的工作副本和服务器上的仓库同
步. 因为仓库是共享的, 所以其他开发人员会向仓库提交他们修改, 这时候你的工作副
本就会落后于仓库.

假设某一项目有 Tom 和 Jerry 两个开发人员, 他们都从仓库中检出了最新版本的代码,
然后各自开始开发. Jerry 的工作效率比较高, 他很快就把修改提交到了仓库上.

这时候, Tom 的工作副本就变成过时了的. 操作 update 会把 Jerry 的修改拉到本地,
然后把 Tom 的工作副本更新到最新版.

\section{执行修改}
\label{sec:perform_changes}

有很多操作都可以对工作副本中的文件产生影响, 编辑是其中最常见的操作, 通过编辑,
文件的内容被添加或删除.

开发人员还可以在工作副本中添加文件或目录, 但是它们并不能立即成为仓库的一部分,
而是被添加到未决的修改列表中, 只有在提交之后才会真正变成仓库的一部分.

类似的, 开发人员还可以删除文件或目录, 删除操作会立刻把工作副本中的对应文件删
除, 但是被删除的文件其实是被添加到了未决的修改列表中, 只有在提交之后, 仓库中
的对应文件才会被删除.

操作 rename 修改文件或目录的名字. 操作 move 把文件或目录从一个位置移动到另一
个位置中.

\section{审核修改}
\label{sec:review_changes}

当开发人员从仓库检出代码, 或更新本地工作副本时, 他们的工作副本就会和仓库同步.
如果开发人员对工作副本进行了修改, 那它们就会比仓库中的代码要新. 在执行操作
commit 之前, 最好对修改进行一下审核.

操作 status 列出工作副本所发生的变化. 我们前面已经说过, 无论何时对工作副本中
的文件作出修改, 这些修改就会变成未决的修改列表的一部分. 操作 status 用于查看
未决的修改列表.

操作 status 只会列出发生变化的文件或目录, 但不会显示具体的修改细节. 操作
diff 用来查看工作副本中的文件内容具体发生了哪些变化.

\section{修正错误}
\label{sec:fix_mistakes}

假设某个开发人员对工作副本进行了一些修改, 但是现在他想撤消这些修改, 这时候,
可以执行操作 revert.

操作 revert 可以撤消工作副本的所有修改, 也可以针对一个或多个文件/目录进行撤
消. 如果是对整个工作副本进行撤消, 操作 revert 就会销毁未决的修改列表, 把工
作副本恢复到修改前的状态.

\section{解决冲突}
\label{sec:resolve_conflicts}

冲突会在合并时发生. 操作 merge 会自动处理可以安全合并的情况, 除此之外的情况
都会被当作冲突. 例如, 文件 \texttt{hello.c} 在一个分支中被修改, 而在另一个
分支中被删除, 因此在合并这两个分支时开发人员就要作出决定. 操作 resolve 可以
帮助开发人员解决冲突, 并通知 VCS 如何处理冲突情况.

\section{提交修改}
\label{sec:commit_changes}

操作 commit 把工作副本所发生的变化应用到仓库中. 这个操作会修改仓库中的代码,
其他开发人员可以通过更新来查看新提交的修改.

在提交前, 开发人员要把文件/目录添加到未决的修改列表上, 这是修改等待提交的地
方. 在提交时, 开发人员通常要写上提交日志, 在日志中解释为什么这次修改是必要
的, 提交日志会成为仓库历史的一部分. 提交是一种原子操作, 要么全部修改都提交
上去, 要么一个也没有, 不可能看到只提交一半的修改.

\chapter{检出}
\label{chap:checkout_process}

Subversion 提供了命令 \texttt{checkout}, 用于从仓库中检出工作副本. 下面的命令
会在当前目录下创建一个新目录: \texttt{project\_repo}. 不用对命令中仓库的 URL
感到担心, 在大多数情况下, subversion 管理员知道如何拼写 URL, 而且配置了适当的
访问权限控制:
\begin{svnshell}
[tom@CentOS ~]$ svn checkout&\index{\texttt{svn}!\texttt{checkout}}& http://svn.server.com/svn/project_repo --username=tom
\end{svnshell}

上面命令的输出信息类似于:
\begin{svnshell}
A	project_repo/trunk
A	project_repo/branches
A	project_repo/tags
Checked out revision 1.
\end{svnshell}

如果检出成功, 命令就会打印修订号. 如果用户想要知道关于仓库的更多信息, 可以使用
命令 \texttt{info}:
\begin{svnshell}
[tom@CentOS trunk]$ pwd
/home/tom/project_repo/trunk
[tom@CentOS trunk]$ svn info&\index{\texttt{svn}!\texttt{info}}&
\end{svnshell}
上面命令的输出信息类似于:
\begin{svnshell}
Path: .
URL: http://svn.server.com/svn/project_repo/trunk
Repository Root: http://svn.server.com/svn/project_repo
Repository UUID: 7ceef8cb-3799-40dd-a067-c216ec2e5247
Revision: 1
Node Kind: directory
Schedule: normal
Last Changed Author: jerry
Last Changed Rev: 0
Last Changed Date: 2013-08-24 18:15:52 +0530 (Sat, 24 Aug 2013)
[tom@CentOS trunk]$
\end{svnshell}

\chapter{执行修改}
\label{chap:perform_changes}

假设 Jerry 从仓库中检出了最新的版本, 然后开始对项目进行开发, 他首先在主干目
录内创建了一个 \texttt{array.c} 文件:
\begin{svnshell}
[jerry@CentOS ~]$ cd project_repo/trunk/
[jerry@CentOS trunk]$ cat&\index{\texttt{cat}}& array.c
\end{svnshell}
命令的输出内容是:
\begin{ccode}
#include <stdio.h>

#define MAX 16

int main(void)
{
	int i, n, arr[MAX];

	printf("Enter the total number of elements: ");
	scanf("%d", &n);

	printf("Enter the elements\n");

	for (i = 0; i < n; i++)
		scanf("%d", &arr[i]);

	printf("Array has folloing elements\n");
	for (i = 0; i < n; i++)
		printf("|%d| ", arr[i]);

	printf("\n");

	return 0;
}
\end{ccode}

他想在提交之前先测试一下代码:
\begin{svnshell}
[jerry@CentOS trunk]$ make array
cc	array.c -o array
[jerry@CentOS trunk]$ ./array
Enter the total number of elements: 5
Enter the elements
1
2
3
4
5
Array has following elements
|1| |2| |3| |4| |5| 
\end{svnshell}
编译和运行看来都没什么问题, 现在他准备提交代码.

\begin{svnshell}
[jerry@CentOS trunk]$ svn status&\index{\texttt{svn}!\texttt{status}}&
?	array.c
?	array
\end{svnshell}
如果 subversion 不知道如何处理某些文件, 就会在文件名的左边打印一个问号
\texttt{?}.

在提交前, Jerry 需要把文件 \texttt{array.c} 添加到未决的变化列表上:
\begin{svnshell}
[jerry@CentOS trunk]$ svn add&\index{\texttt{svn}!\texttt{add}}& array.c
A	array.c
\end{svnshell}

现在让我们再检查一下工作副本的状态:
\begin{svnshell}
[jerry@CentOS trunk]$ svn status&\index{\texttt{svn}!\texttt{status}}&
?	array
A	array.c
\end{svnshell}
\texttt{array.c} 左边的 \texttt{A} 表示该文件已经成功地添加到了未决的变化列
表上.

为了把 \texttt{array.c} 更新到仓库中, 需要执行命令 \texttt{commit}, 并带上参数
\texttt{-m}, 这样我们就可以直接在命令行上写提交信息, 如果省略了参数
\texttt{-m}, subversion 就会自动打开一个文本编辑器, 开发人员也可以在编辑器中
写提交信息:
\begin{svnshell}
[jerry@CentOS trunk]$ svn commit&\index{\svn!\svnci}& -m "Initial commit"
Adding		trunk/array.c
Transmitting file data .
Committed revision 2.
\end{svnshell}
现在, 文件 \texttt{array.c} 就已经成功地添加到了仓库中, 修订号也相应地进行了
更新.

\printindex

\end{document}
